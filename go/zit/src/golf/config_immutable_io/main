package env_repo

import (
	"bufio"
	"bytes"
	"encoding/gob"
	"fmt"
	"io"
	"os"

	"code.linenisgreat.com/zit/go/zit/src/alfa/errors"
	"code.linenisgreat.com/zit/go/zit/src/alfa/interfaces"
	"code.linenisgreat.com/zit/go/zit/src/alfa/toml"
	"code.linenisgreat.com/zit/go/zit/src/charlie/files"
	"code.linenisgreat.com/zit/go/zit/src/charlie/ohio"
	"code.linenisgreat.com/zit/go/zit/src/delta/config_immutable"
	"code.linenisgreat.com/zit/go/zit/src/echo/env_dir"
	"code.linenisgreat.com/zit/go/zit/src/echo/format"
	"code.linenisgreat.com/zit/go/zit/src/echo/ids"
	"code.linenisgreat.com/zit/go/zit/src/echo/triple_hyphen_io"
	"code.linenisgreat.com/zit/go/zit/src/foxtrot/builtin_types"
)

type ConfigImmutableReader struct {
	ConfigLoaded ConfigLoaded
}

func (s *ConfigImmutableReader) ReadFromFile(
	p string,
) (err error) {
	var r io.Reader

	{
		var f *os.File

		if f, err = files.OpenExclusiveReadOnly(p); err != nil {
			if errors.IsNotExist(err) {
				err = nil
				r = bytes.NewBuffer(nil)
			} else {
				err = errors.Wrap(err)
				return
			}
		} else {
			defer errors.DeferredCloser(&err, f)

			r = f
		}
	}

	if _, err = s.ReadFrom(r); err != nil {
		err = errors.Wrap(err)
		return
	}

	return
}

func (s *ConfigImmutableReader) ReadFrom(r io.Reader) (n int64, err error) {
	thr := triple_hyphen_io.Reader{
		Metadata: metadata{ConfigLoaded: &s.ConfigLoaded},
		Blob:     &s.ConfigLoaded,
	}

	if n, err = thr.ReadFrom(r); err != nil {
		err = errors.Wrap(err)
		return
	}

	s.ConfigLoaded.BlobStoreImmutableConfig = env_dir.MakeConfigFromImmutableBlobConfig(
		s.ConfigLoaded.ImmutableConfig.GetBlobStoreConfigImmutable(),
	)

	return
}

type ConfigLoaded struct {
	ids.Type
	ImmutableConfig          config_immutable.Config
	BlobStoreImmutableConfig env_dir.Config
}

type metadata struct {
	*ConfigLoaded
}

func (m metadata) ReadFrom(r1 io.Reader) (n int64, err error) {
	r := bufio.NewReader(r1)

	if n, err = format.ReadLines(
		r,
		ohio.MakeLineReaderRepeat(
			ohio.MakeLineReaderKeyValues(
				map[string]interfaces.FuncSetString{
					"!": m.Type.Set,
				},
			),
		),
	); err != nil {
		err = errors.Wrap(err)
		return
	}

	return
}

func (m metadata) WriteTo(w io.Writer) (n int64, err error) {
	var n1 int
	n1, err = fmt.Fprintf(w, "! %s\n", m.Type.StringSansOp())
	n += int64(n1)

	if err != nil {
		err = errors.Wrap(err)
		return
	}

	return
}

func (c *ConfigLoaded) ReadFrom(r io.Reader) (n int64, err error) {
	switch c.Type.String() {
	case builtin_types.ImmutableConfigV1:
		c.ImmutableConfig = &config_immutable.TomlV1{}
		td := toml.NewDecoder(r)

		if err = td.Decode(c.ImmutableConfig); err != nil {
			if err == io.EOF {
				err = nil
			} else {
				err = errors.Wrap(err)
				return
			}
		}

	case "":
		c.ImmutableConfig = &config_immutable.V0{}

		dec := gob.NewDecoder(r)

		if err = dec.Decode(c.ImmutableConfig); err != nil {
			if err == io.EOF {
				err = nil
			} else {
				err = errors.Wrap(err)
				return
			}
		}

	default:
		err = errors.Errorf("unsupported config type: %q", c.Type)
		return
	}

	c.BlobStoreImmutableConfig = env_dir.MakeConfigFromImmutableBlobConfig(
		c.ImmutableConfig.GetBlobStoreConfigImmutable(),
	)

	return
}

func (s *ConfigLoaded) WriteTo(w io.Writer) (n int64, err error) {
	switch s.Type.String() {
	case builtin_types.ImmutableConfigV1:
		te := toml.NewEncoder(w)

		if err = te.Encode(s.ImmutableConfig); err != nil {
			if err == io.EOF {
				err = nil
			} else {
				err = errors.Wrap(err)
				return
			}
		}

	case "":
		dec := gob.NewEncoder(w)

		if err = dec.Encode(s.ImmutableConfig); err != nil {
			if err == io.EOF {
				err = nil
			} else {
				err = errors.Wrap(err)
				return
			}
		}

	default:
		err = errors.Errorf("unsupported config type: %q", s.Type)
		return
	}

	return
}
