package catgut

import (
	"bufio"
	"io"
)

// scannerExperimental provides a convenient interface for reading data such as
// a file of newline-delimited lines of text. Successive calls to
// the Scan method will step through the 'tokens' of a file, skipping
// the bytes between the tokens. The specification of a token is
// defined by a split function of type SplitFunc; the default split
// function breaks the input into lines with line termination stripped. Split
// functions are defined in this package for scanning a file into
// lines, bytes, UTF-8-encoded runes, and space-delimited words. The
// client may instead provide a custom split function.
//
// Scanning stops unrecoverably at EOF, the first I/O error, or a token too
// large to fit in the buffer. When a scan stops, the reader may have
// advanced arbitrarily far past the last token. Programs that need more
// control over error handling or large tokens, or must run sequential scans
// on a reader, should use bufio.Reader instead.
type scannerExperimental struct {
	r            *RingBuffer           // The reader provided by the client.
	split        SplitFuncExperimental // The function to split the tokens.
	maxTokenSize int                   // Maximum size of a token; modified by tests.
	token        []byte                // Last token returned by split.
	buf          Slice                 // Buffer used as argument to split.
	start        int                   // First non-processed byte in buf.
	end          int                   // End of data in buf.
	err          error                 // Sticky error.
	empties      int                   // Count of successive empty tokens.
	scanCalled   bool                  // Scan has been called; buffer is in use.
	done         bool                  // Scan has finished.
}

// SplitFunc is the signature of the split function used to tokenize the
// input. The arguments are an initial substring of the remaining unprocessed
// data and a flag, atEOF, that reports whether the Reader has no more data
// to give. The return values are the number of bytes to advance the input
// and the next token to return to the user, if any, plus an error, if any.
//
// Scanning stops if the function returns an error, in which case some of
// the input may be discarded. If that error is ErrFinalToken, scanning
// stops with no error.
//
// Otherwise, the scannerExperimental advances the input. If the token is not nil,
// the scannerExperimental returns it to the user. If the token is nil, the
// scannerExperimental reads more data and continues scanning; if there is no more
// data--if atEOF was true--the scannerExperimental returns. If the data does not
// yet hold a complete token, for instance if it has no newline while
// scanning lines, a SplitFunc can return (0, nil, nil) to signal the
// scannerExperimental to read more data into the slice and try again with a
// longer slice starting at the same point in the input.
//
// The function is never called with an empty data slice unless atEOF
// is true. If atEOF is true, however, data may be non-empty and,
// as always, holds unprocessed text.
type SplitFuncExperimental func(data Slice, atEOF bool) (advance int, token []byte, err error)

// NewScanner returns a new scannerExperimental to read from r.
// The split function defaults to ScanLines.
func NewScannerExperimental(r *RingBuffer) *scannerExperimental {
	return &scannerExperimental{
		r:            r,
		maxTokenSize: bufio.MaxScanTokenSize,
	}
}

// Err returns the first non-EOF error that was encountered by the scannerExperimental.
func (s *scannerExperimental) Err() error {
	if s.err == io.EOF {
		return nil
	}

	return s.err
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *scannerExperimental) Bytes() []byte {
	return s.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *scannerExperimental) Text() []byte {
	return s.token
}

// Scan advances the scannerExperimental to the next token, which will then be
// available through the Bytes or Text method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
// Scan panics if the split function returns too many empty
// tokens without advancing the input. This is a common error mode for
// scanners.
func (s *scannerExperimental) Scan() bool {
	if s.done {
		return false
	}

	s.scanCalled = true

	// Loop until we have a token.
	for {

		// See if we can get a token with what we already have.
		// If we've run out of data but have an error, give the split function
		// a chance to recover any remaining, possibly empty token.
		if s.end > s.start || s.err != nil {
			advance, token, err := s.split(s.buf.Slice(s.start, s.end), s.err != nil)
			if err != nil {
				if err == bufio.ErrFinalToken {
					s.token = token
					s.done = true
					return true
				}

				s.setErr(err)

				return false
			}

			if !s.advance(advance) {
				return false
			}

			s.token = token

			if token != nil {
				if s.err == nil || advance > 0 {
					s.empties = 0
				} else {
					// Returning tokens not advancing input at EOF.
					s.empties++

					// if s.empties > maxConsecutiveEmptyReads {
					if s.empties > 100 {
						panic("bufio.Scan: too many empty tokens without progressing")
					}
				}

				return true
			}
		}

		// We cannot generate a token with what we are holding.
		// If we've already hit EOF or an I/O error, we are done.
		if s.err != nil {
			// Shut it down.
			s.start = 0
			s.end = 0
			return false
		}

		s.r.Fill()
	}
}

// advance consumes n bytes of the buffer. It reports whether the advance was legal.
func (s *scannerExperimental) advance(n int) bool {
	if n < 0 {
		s.setErr(bufio.ErrNegativeAdvance)
		return false
	}

	if n > s.end-s.start {
		s.setErr(bufio.ErrAdvanceTooFar)
		return false
	}

	s.start += n

	return true
}

// setErr records the first error encountered.
func (s *scannerExperimental) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}

// Split sets the split function for the scannerExperimental.
// The default split function is ScanLines.
//
// Split panics if it is called after scanning has started.
func (s *scannerExperimental) Split(split SplitFuncExperimental) {
	if s.scanCalled {
		panic("Split called after Scan")
	}

	s.split = split
}
